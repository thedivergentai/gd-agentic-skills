[
  {
    "name": "godot-2d-animation",
    "description": "Expert patterns for 2D animation in Godot using AnimatedSprite2D and skeletal cutout rigs. Use when implementing sprite frame animations, procedural animation (squash/stretch), cutout bone hierarchies, or frame-perfect timing systems. Trigger keywords: AnimatedSprite2D, SpriteFrames, animation_finished, animation_looped, frame_changed, frame_progress, set_frame_and_progress, cutout animation, skeletal 2D, Bone2D, procedural animation, animation state machine, advance(0).",
    "keywords": [
      "AnimatedSprite2D",
      "SpriteFrames",
      "animation_finished",
      "animation_looped",
      "frame_changed",
      "frame_progress",
      "set_frame_and_progress",
      "cutout animation",
      "skeletal 2D",
      "Bone2D",
      "procedural animation",
      "animation state machine",
      "advance(0)"
    ]
  },
  {
    "name": "godot-2d-physics",
    "description": "Expert patterns for Godot 2D physics including collision layers/masks, Area2D triggers, raycasting, and PhysicsDirectSpaceState2D queries. Use when implementing collision detection, trigger zones, line-of-sight systems, or manual physics queries. Trigger keywords: CollisionShape2D, CollisionPolygon2D, collision_layer, collision_mask, set_collision_layer_value, set_collision_mask_value, Area2D, body_entered, body_exited, RayCast2D, force_raycast_update, PhysicsPointQueryParameters2D, PhysicsShapeQueryParameters2D, direct_space_state, move_and_collide, move_and_slide.",
    "keywords": [
      "CollisionShape2D",
      "CollisionPolygon2D",
      "collision_layer",
      "collision_mask",
      "set_collision_layer_value",
      "set_collision_mask_value",
      "Area2D",
      "body_entered",
      "body_exited",
      "RayCast2D",
      "force_raycast_update",
      "PhysicsPointQueryParameters2D",
      "PhysicsShapeQueryParameters2D",
      "direct_space_state",
      "move_and_collide",
      "move_and_slide"
    ]
  },
  {
    "name": "godot-3d-lighting",
    "description": "Expert patterns for Godot 3D lighting including DirectionalLight3D shadow cascades, OmniLight3D attenuation, SpotLight3D projectors, VoxelGI vs SDFGI, and LightmapGI baking. Use when implementing realistic 3D lighting, shadow optimization, global illumination, or light probes. Trigger keywords: DirectionalLight3D, OmniLight3D, SpotLight3D, shadow_enabled, directional_shadow_mode, directional_shadow_split, omni_range, omni_attenuation, spot_range, spot_angle, VoxelGI, SDFGI, LightmapGI, ReflectionProbe, Environment, WorldEnvironment.",
    "keywords": [
      "DirectionalLight3D",
      "OmniLight3D",
      "SpotLight3D",
      "shadow_enabled",
      "directional_shadow_mode",
      "directional_shadow_split",
      "omni_range",
      "omni_attenuation",
      "spot_range",
      "spot_angle",
      "VoxelGI",
      "SDFGI",
      "LightmapGI",
      "ReflectionProbe",
      "Environment",
      "WorldEnvironment"
    ]
  },
  {
    "name": "godot-3d-materials",
    "description": "Expert patterns for Godot 3D PBR materials using StandardMaterial3D including albedo, metallic/roughness workflows, normal maps, ORM texture packing, transparency modes, and shader conversion. Use when creating realistic 3D surfaces, PBR workflows, or material optimization. Trigger keywords: StandardMaterial3D, BaseMaterial3D, albedo_texture, metallic, metallic_texture, roughness, roughness_texture, normal_texture, normal_enabled, orm_texture, transparency, alpha_scissor, alpha_hash, cull_mode, ShaderMaterial, shader parameters.",
    "keywords": [
      "StandardMaterial3D",
      "BaseMaterial3D",
      "albedo_texture",
      "metallic",
      "metallic_texture",
      "roughness",
      "roughness_texture",
      "normal_texture",
      "normal_enabled",
      "orm_texture",
      "transparency",
      "alpha_scissor",
      "alpha_hash",
      "cull_mode",
      "ShaderMaterial",
      "shader parameters"
    ]
  },
  {
    "name": "godot-3d-world-building",
    "description": "Expert patterns for 3D level design using GridMap with MeshLibrary, CSG constructive solid geometry, WorldEnvironment setup, ProceduralSkyMaterial, and volumetric fog. Use when building 3D levels, modular tilesets, BSP-style geometry, or environmental effects. Trigger keywords: GridMap, MeshLibrary, set_cell_item, get_cell_item, map_to_local, local_to_map, CSGCombiner3D, CSGBox3D, CSGSphere3D, CSGPolygon3D, WorldEnvironment, Environment, Sky, ProceduralSkyMaterial, PanoramaSkyMaterial, fog_enabled, volumetric_fog_enabled.",
    "keywords": [
      "GridMap",
      "MeshLibrary",
      "set_cell_item",
      "get_cell_item",
      "map_to_local",
      "local_to_map",
      "CSGCombiner3D",
      "CSGBox3D",
      "CSGSphere3D",
      "CSGPolygon3D",
      "WorldEnvironment",
      "Environment",
      "Sky",
      "ProceduralSkyMaterial",
      "PanoramaSkyMaterial",
      "fog_enabled",
      "volumetric_fog_enabled"
    ]
  },
  {
    "name": "godot-ability-system",
    "description": "Expert patterns for RPG/action ability systems including cooldown strategies, combo systems, ability chaining, skill trees with prerequisites, upgrade paths, and resource management. Use when implementing unlockable abilities, character progression, or complex skill systems. Trigger keywords: PlayerAbility, AbilityManager, cooldown, SkillTree, SkillNode, prerequisites, can_use, execute, ComboSystem, ability_chain, global_cooldown, charge_system, upgrade_path.",
    "keywords": [
      "PlayerAbility",
      "AbilityManager",
      "cooldown",
      "SkillTree",
      "SkillNode",
      "prerequisites",
      "can_use",
      "execute",
      "ComboSystem",
      "ability_chain",
      "global_cooldown",
      "charge_system",
      "upgrade_path"
    ]
  },
  {
    "name": "godot-adapt-2d-to-3d",
    "description": "Expert patterns for migrating 2D games to 3D including node type conversions, camera systems (third-person, first-person, orbit), physics layer migration, sprite-to-model art pipeline, and control scheme adaptations. Use when porting 2D projects to 3D or adding 3D elements. Trigger keywords: CharacterBody2D to CharacterBody3D, Area2D to Area3D, Camera2D to Camera3D, Vector2 to Vector3, collision_layer migration, sprite to MeshInstance3D, 2D to 3D conversion.",
    "keywords": [
      "CharacterBody2D to CharacterBody3D",
      "Area2D to Area3D",
      "Camera2D to Camera3D",
      "Vector2 to Vector3",
      "collision_layer migration",
      "sprite to MeshInstance3D",
      "2D to 3D conversion"
    ]
  },
  {
    "name": "godot-adapt-3d-to-2d",
    "description": "Expert patterns for simplifying 3D games to 2D including dimension reduction strategies, camera flattening, physics conversion, 3D-to-sprite art pipeline, and control simplification. Use when porting 3D to 2D, creating 2D versions for mobile, or prototyping. Trigger keywords: CharacterBody3D to CharacterBody2D, Camera3D to Camera2D, Vector3 to Vector2, flatten Z-axis, orthogonal projection, 3D to sprite conversion, performance optimization.",
    "keywords": [
      "CharacterBody3D to CharacterBody2D",
      "Camera3D to Camera2D",
      "Vector3 to Vector2",
      "flatten Z-axis",
      "orthogonal projection",
      "3D to sprite conversion",
      "performance optimization"
    ]
  },
  {
    "name": "godot-adapt-desktop-to-mobile",
    "description": "Expert patterns for porting desktop games to mobile including touch control schemes (virtual joystick, gesture detection), UI scaling for small screens, performance optimization for mobile GPUs, battery life management, and platform-specific features. Use when creating mobile ports or cross-platform mobile builds. Trigger keywords: TouchScreenButton, virtual_joystick, gesture_detector, InputEventScreenTouch, InputEventScreenDrag, mobile_optimization, battery_saving, adaptive_performance, MOBILE_ENABLED.",
    "keywords": [
      "TouchScreenButton",
      "virtual_joystick",
      "gesture_detector",
      "InputEventScreenTouch",
      "InputEventScreenDrag",
      "mobile_optimization",
      "battery_saving",
      "adaptive_performance",
      "MOBILE_ENABLED"
    ]
  },
  {
    "name": "godot-adapt-mobile-to-desktop",
    "description": "Expert patterns for scaling mobile games to desktop including mouse/keyboard controls, increased resolution and graphical fidelity, expanded UI layouts, settings menus, window management, and platform-specific features. Use when creating desktop ports or cross-platform releases. Trigger keywords: mouse_controls, keyboard_shortcuts, resolution_scaling, graphics_settings, fullscreen_toggle, window_modes, Steam_integration, desktop_optimization.",
    "keywords": [
      "mouse_controls",
      "keyboard_shortcuts",
      "resolution_scaling",
      "graphics_settings",
      "fullscreen_toggle",
      "window_modes",
      "Steam_integration",
      "desktop_optimization"
    ]
  },
  {
    "name": "godot-adapt-single-to-multiplayer",
    "description": "Expert patterns for adding multiplayer to single-player games including client-server architecture, authoritative server design, MultiplayerSynchronizer, lag compensation (client prediction, server reconciliation), input buffering, and anti-cheat measures. Use when retrofitting multiplayer, porting to online play, or designing networked gameplay. Trigger keywords: MultiplayerPeer, ENetMultiplayerPeer, SceneMultiplayer, MultiplayerSynchronizer, rpc, rpc_id, multiplayer_authority, client_prediction, server_reconciliation, lag_compensation, rollback.",
    "keywords": [
      "MultiplayerPeer",
      "ENetMultiplayerPeer",
      "SceneMultiplayer",
      "MultiplayerSynchronizer",
      "rpc",
      "rpc_id",
      "multiplayer_authority",
      "client_prediction",
      "server_reconciliation",
      "lag_compensation",
      "rollback"
    ]
  },
  {
    "name": "godot-animation-player",
    "description": "Expert patterns for AnimationPlayer including track types (Value, Method, Audio, Bezier), root motion extraction, animation callbacks, procedural animation generation, call mode optimization, and RESET tracks. Use for timeline-based animations, cutscenes, or UI transitions. Trigger keywords: AnimationPlayer, Animation, track_insert_key, root_motion, animation_finished, RESET_track, call_mode, animation_set_next, queue, blend_times.",
    "keywords": [
      "AnimationPlayer",
      "Animation",
      "track_insert_key",
      "root_motion",
      "animation_finished",
      "RESET_track",
      "call_mode",
      "animation_set_next",
      "queue",
      "blend_times"
    ]
  },
  {
    "name": "godot-animation-tree-mastery",
    "description": "Expert patterns for AnimationTree including StateMachine transitions, BlendSpace2D for directional movement, BlendTree for layered animations, root motion, transition conditions, advance expressions, and state machine sub-states. Use for complex character animation systems with movement blending and state management. Trigger keywords: AnimationTree, AnimationNodeStateMachine, BlendSpace2D, BlendSpace1D, BlendTree, transition_request, blend_position, advance_expression, AnimationNodeAdd2, AnimationNodeBlend2, root_motion.",
    "keywords": [
      "AnimationTree",
      "AnimationNodeStateMachine",
      "BlendSpace2D",
      "BlendSpace1D",
      "BlendTree",
      "transition_request",
      "blend_position",
      "advance_expression",
      "AnimationNodeAdd2",
      "AnimationNodeBlend2",
      "root_motion"
    ]
  },
  {
    "name": "godot-audio-systems",
    "description": "Expert patterns for Godot audio including AudioStreamPlayer variants (2D positional, 3D spatial), AudioBus mixing architecture, dynamic effects (reverb, EQ,compression), audio pooling for performance, music transitions (crossfade, bpm-sync), and procedural audio generation. Use for music systems, sound effects, spatial audio, or audio-reactive gameplay. Trigger keywords: AudioStreamPlayer, AudioStreamPlayer2D, AudioStreamPlayer3D, AudioBus, AudioServer, AudioEffect, music_crossfade, audio_pool, positional_audio, reverb, bus_volume.",
    "keywords": [
      "AudioStreamPlayer",
      "AudioStreamPlayer2D",
      "AudioStreamPlayer3D",
      "AudioBus",
      "AudioServer",
      "AudioEffect",
      "music_crossfade",
      "audio_pool",
      "positional_audio",
      "reverb",
      "bus_volume"
    ]
  },
  {
    "name": "godot-autoload-architecture",
    "description": "Expert patterns for Godot AutoLoad (singleton) architecture including global state management, scene transitions, signal-based communication, dependency injection, autoload initialization order, and anti-patterns to avoid. Use for game managers, save systems, audio controllers, or cross-scene resources. Trigger keywords: AutoLoad, singleton, GameManager, SceneTransitioner, SaveManager, global_state, autoload_order, signal_bus, dependency_injection.",
    "keywords": [
      "AutoLoad",
      "singleton",
      "GameManager",
      "SceneTransitioner",
      "SaveManager",
      "global_state",
      "autoload_order",
      "signal_bus",
      "dependency_injection"
    ]
  },
  {
    "name": "godot-camera-systems",
    "description": "Expert patterns for 2D/3D camera control including smooth following (lerp, position_smoothing), camera shake (trauma system), screen shake with frequency parameters, deadzone/drag for platformers, look-ahead prediction, and camera transitions. Use for player cameras, cin",
    "keywords": [
      "trauma",
      "platformers",
      "parameters",
      "with",
      "cameras",
      "position_smoothing",
      "patterns",
      "camera",
      "system",
      "control",
      "ahead",
      "including",
      "smooth",
      "drag",
      "following",
      "lerp",
      "expert",
      "frequency",
      "transitions",
      "shake",
      "screen",
      "prediction",
      "look",
      "player",
      "deadzone"
    ]
  },
  {
    "name": "godot-characterbody-2d",
    "description": "Expert patterns for CharacterBody2D including platformer movement (coyote time, jump buffering, variable jump height), top-down movement (8-way, tank controls), collision handling, one-way platforms, and state machines. Use for player characters, NPCs, or enemies. Trigger keywords: CharacterBody2D, move_and_slide, is_on_floor, coyote_time, jump_buffer, velocity, get_slide_collision, one_way_platforms, state_machine.",
    "keywords": [
      "CharacterBody2D",
      "move_and_slide",
      "is_on_floor",
      "coyote_time",
      "jump_buffer",
      "velocity",
      "get_slide_collision",
      "one_way_platforms",
      "state_machine"
    ]
  },
  {
    "name": "godot-combat-system",
    "description": "Expert patterns for combat systems including hitbox/hurtbox architecture, damage calculation (DamageData class), health components, combat state machines, combo systems, ability cooldowns, and damage popups. Use for action games, RPGs, or fighting games. Trigger keywords: Hitbox, Hurtbox, DamageData, HealthComponent, combat_state, combo_system, ability_cooldown, invincibility_frames, damage_popup.",
    "keywords": [
      "Hitbox",
      "Hurtbox",
      "DamageData",
      "HealthComponent",
      "combat_state",
      "combo_system",
      "ability_cooldown",
      "invincibility_frames",
      "damage_popup"
    ]
  },
  {
    "name": "godot-composition",
    "description": "Expert architectural standards for building scalable Godot GAMES (RPGs, Platformers, Shooters) using the Composition pattern (Entity-Component). Use when designing player controllers, NPCs, enemies, weapons, or complex gameplay systems. Enforces \"Has-A\" relationships for game entities. Trigger keywords: Entity-Component, ECS, Gameplay, Actors, NPCs, Enemies, Weapons, Hitboxes, Game Loop, Level Design.",
    "keywords": [
      "Entity-Component",
      "ECS",
      "Gameplay",
      "Actors",
      "NPCs",
      "Enemies",
      "Weapons",
      "Hitboxes",
      "Game Loop",
      "Level Design"
    ]
  },
  {
    "name": "godot-composition-apps",
    "description": "Expert architectural standards for building scalable Godot applications (Apps, Tools, UI, or Games) using the Composition pattern. Use when designing node structures, refactoring monolithic scripts, or implementing complex behaviors. Enforces \"Has-A\" relationships over \"Is-A\" inheritance.",
    "keywords": [
      "relationships",
      "monolithic",
      "composition",
      "enforces",
      "designing",
      "godot",
      "scalable",
      "node",
      "implementing",
      "structures",
      "standards",
      "pattern",
      "applications",
      "behaviors",
      "inheritance",
      "using",
      "refactoring",
      "scripts",
      "over",
      "games",
      "complex",
      "expert",
      "tools",
      "apps",
      "building",
      "when",
      "architectural"
    ]
  },
  {
    "name": "godot-debugging-profiling",
    "description": "Expert debugging workflows including print debugging (push_warning, push_error, assert), breakpoints (conditional breakpoints), Godot Debugger (stack trace, variables, remote debug), profiler (time profiler, memory monitor), error handling patterns, and performance optimization. Use for bug fixing, performance tuning, or development diagnostics. Trigger keywords: breakpoint, print_debug, push_error, assert, profiler, remote_debug, memory_leak, orphan_nodes, Performance.get_monitor.",
    "keywords": [
      "breakpoint",
      "print_debug",
      "push_error",
      "assert",
      "profiler",
      "remote_debug",
      "memory_leak",
      "orphan_nodes",
      "Performance"
    ]
  },
  {
    "name": "godot-dialogue-system",
    "description": "Expert patterns for branching dialogue systems including dialogue graphs (Resource-based), character portraits, player choices, conditional dialogue (flags/quests), typewriter effects, localization support, and voice acting integration. Use for narrative games, RPGs, or visual novels. Trigger keywords: DialogueLine, DialogueChoice, DialogueGraph, dialogue_manager, typewriter_effect, branching_dialogue, dialogue_flags, localization, voice_acting.",
    "keywords": [
      "DialogueLine",
      "DialogueChoice",
      "DialogueGraph",
      "dialogue_manager",
      "typewriter_effect",
      "branching_dialogue",
      "dialogue_flags",
      "localization",
      "voice_acting"
    ]
  },
  {
    "name": "godot-economy-system",
    "description": "Expert patterns for game economies including currency management (multi-currency, wallet system), shop systems (buy/sell prices, stock limits), dynamic pricing (supply/demand), loot tables (weighted drops, rarity tiers), and economic balance (inflation control, currency sinks). Use for RPGs, trading games, or resource management systems. Trigger keywords: EconomyManager, currency, shop_item, loot_table, dynamic_pricing, buy_sell_spread, currency_sink, inflation, item_rarity.",
    "keywords": [
      "EconomyManager",
      "currency",
      "shop_item",
      "loot_table",
      "dynamic_pricing",
      "buy_sell_spread",
      "currency_sink",
      "inflation",
      "item_rarity"
    ]
  },
  {
    "name": "godot-export-builds",
    "description": "Expert patterns for multi-platform exports including export templates (Windows/Linux/macOS/Android/iOS/Web), command-line exports (headless mode), platform-specific settings (codesign, notarization, Android SDK), feature flags (OS.has_feature), CI/CD pipelines (GitHub Actions), and build optimization (size reduction, debug stripping). Use for release preparation or automated deployment. Trigger keywords: export_preset, export_template, headless_export, platform_specific, feature_flag, CI_CD, build_optimization, codesign, Android_SDK.",
    "keywords": [
      "export_preset",
      "export_template",
      "headless_export",
      "platform_specific",
      "feature_flag",
      "CI_CD",
      "build_optimization",
      "codesign",
      "Android_SDK"
    ]
  },
  {
    "name": "godot-gdscript-mastery",
    "description": "Expert GDScript best practices including static typing (var x\\: int, func -> void), signal architecture (signal up call down), unique node access (%NodeName, @onready), script structure (extends, class_name, signals, exports, methods), and performance patterns (dict.get with defaults, avoid get_node in loops). Use for code review, refactoring, or establishing project standards. Trigger keywords: static_typing, signal_architecture, unique_nodes, @onready, class_name, signal_up_call_down, gdscript_style_guide.",
    "keywords": [
      "static_typing",
      "signal_architecture",
      "unique_nodes",
      "@onready",
      "class_name",
      "signal_up_call_down",
      "gdscript_style_guide"
    ]
  },
  {
    "name": "godot-genre-action-rpg",
    "description": "Comprehensive blueprint for Action RPGs including real-time combat (hitbox/hurtbox, stat-based damage), character progression (RPG stats, leveling, skill trees), loot systems (procedural item generation, affixes, rarity tiers), equipment systems (gear slots, stat modifiers), and ability systems (cooldowns, mana cost, AOE). Based on expert ARPG design from Diablo, Path of Exile, Souls-like developers. Trigger keywords: action_rpg, loot_generator, rpg_stats, skill_tree, hitbox_combat, item_affixes, equipment_slots, ability_cooldown, stat_scaling.",
    "keywords": [
      "action_rpg",
      "loot_generator",
      "rpg_stats",
      "skill_tree",
      "hitbox_combat",
      "item_affixes",
      "equipment_slots",
      "ability_cooldown",
      "stat_scaling"
    ]
  },
  {
    "name": "godot-genre-battle-royale",
    "description": "Expert blueprint for Battle Royale games including shrinking zone/storm mechanics (phase-based, damage scaling), large-scale networking (relevancy, tick rate optimization), deployment systems (plane, freefall, parachute), loot spawning (weighted tables, rarity), and performance optimization (LOD, occlusion culling, object pooling). Use for multiplayer survival games or last-one-standing formats. Trigger keywords: battle_royale, zone_shrink, storm_damage, deployment_system, loot_spawn, networking_optimization, relevancy_system, snapshot_interpolation.",
    "keywords": [
      "battle_royale",
      "zone_shrink",
      "storm_damage",
      "deployment_system",
      "loot_spawn",
      "networking_optimization",
      "relevancy_system",
      "snapshot_interpolation"
    ]
  },
  {
    "name": "godot-genre-card-game",
    "description": "Expert blueprint for digital card games (CCG/Deckbuilders) including card data structures (Resource-based), deck management (draw/discard/reshuffle), turn logic, hand layout (arcing), drag-and-drop UI, effect resolution (Command pattern), and visual polish (godot-tweening, shaders). Use for CCG, deckbuilders, or tactical card games. Trigger keywords: card_game, deck_manager, card_data, hand_layout, drag_drop_cards, effect_resolution, command_pattern, draw_pile, discard_pile.",
    "keywords": [
      "card_game",
      "deck_manager",
      "card_data",
      "hand_layout",
      "drag_drop_cards",
      "effect_resolution",
      "command_pattern",
      "draw_pile",
      "discard_pile"
    ]
  },
  {
    "name": "godot-genre-educational",
    "description": "Expert blueprint for educational games including gamification loops (learn/apply/feedback/adapt), progress tracking (student profiles, mastery %), adaptive difficulty (target 70% success rate), spaced repetition, curriculum trees (prerequisite system), and visual feedback (confetti, XP bars). Use for learning apps, training simulations, or edutainment. Trigger keywords: educational_game, gamification, adaptive_difficulty, spaced_repetition, student_profile, curriculum_tree, mastery_tracking.",
    "keywords": [
      "educational_game",
      "gamification",
      "adaptive_difficulty",
      "spaced_repetition",
      "student_profile",
      "curriculum_tree",
      "mastery_tracking"
    ]
  },
  {
    "name": "godot-genre-fighting",
    "description": "Expert blueprint for fighting games including frame data (startup/active/recovery frames, advantage on hit/block), hitbox/hurtbox systems, input buffering (5-10 frames), motion input detection (QCF, DP), combo systems (damage scaling, cancel hierarchy), character states (idle/attacking/hitstun/blockstun), and rollback netcode. Based on FGC competitive design. Trigger keywords: fighting_game, frame_data, hitbox_hurtbox, input_buffer, motion_inputs, combo_system, rollback_netcode, cancel_system, advantage_frames.",
    "keywords": [
      "fighting_game",
      "frame_data",
      "hitbox_hurtbox",
      "input_buffer",
      "motion_inputs",
      "combo_system",
      "rollback_netcode",
      "cancel_system",
      "advantage_frames"
    ]
  },
  {
    "name": "godot-genre-horror",
    "description": "Expert blueprint for horror games including tension pacing (sawtooth wave: buildup/peak/relief), Director system (macro AI controlling pacing), sensory AI (vision/sound detection), sanity/stress systems (camera shake, audio distortion), lighting atmosphere (volumetric fog, dynamic shadows), and \"dual brain\" AI (cheating director + honest senses). Use for psychological horror, survival horror, or atmospheric games. Trigger keywords: horror_game, tension_pacing, director_system, sensory_perception, sanity_system, volumetric_fog, AI_reaction_time.",
    "keywords": [
      "horror_game",
      "tension_pacing",
      "director_system",
      "sensory_perception",
      "sanity_system",
      "volumetric_fog",
      "AI_reaction_time"
    ]
  },
  {
    "name": "godot-genre-idle-clicker",
    "description": "Expert blueprint for idle/clicker games including big number handling (mantissa + exponent system), exponential growth curves (cost_growth_factor 1.15x), generator systems (auto-producers), offline progress calculation, prestige systems (reset for permanent multipliers), number formatting (K/M/B suffixes, scientific notation). Use for incremental games, idle games, or cookie clicker derivatives. Trigger keywords: idle_game, big_number, exponential_growth, generator_system, offline_progress, prestige_system, number_formatting.",
    "keywords": [
      "idle_game",
      "big_number",
      "exponential_growth",
      "generator_system",
      "offline_progress",
      "prestige_system",
      "number_formatting"
    ]
  },
  {
    "name": "godot-genre-metroidvania",
    "description": "Expert blueprint for Metroidvanias including ability-gated exploration (locks/keys), interconnected world design (backtracking with shortcuts), persistent state tracking (collectibles, boss defeats), room transitions (seamless loading), map systems (grid-based revelation), and ability versatility (combat + traversal). Use for exploration platformers or action-adventure games. Trigger keywords: metroidvania, ability_gating, interconnected_world, backtracking, map_system, persistent_state, room_transition, soft_locks.",
    "keywords": [
      "metroidvania",
      "ability_gating",
      "interconnected_world",
      "backtracking",
      "map_system",
      "persistent_state",
      "room_transition",
      "soft_locks"
    ]
  },
  {
    "name": "godot-genre-moba",
    "description": "Expert blueprint for MOBA games including lane logic (minion wave spawning every 30s), tower aggro priority (hero attacking ally > minion > hero), click-to-move controls (RTS-style raycasting), hero ability systems (QWER cooldowns, mana cost), fog of war (SubViewport projections), and authoritative networking (server validates damage). Use for competitive 5v5 or arena games. Trigger keywords: MOBA, lane_manager, minion_waves, tower_aggro, click_to_move, ability_cooldowns, fog_of_war, comeback_mechanics.",
    "keywords": [
      "MOBA",
      "lane_manager",
      "minion_waves",
      "tower_aggro",
      "click_to_move",
      "ability_cooldowns",
      "fog_of_war",
      "comeback_mechanics"
    ]
  },
  {
    "name": "godot-genre-open-world",
    "description": "Expert blueprint for open world games including chunk-based streaming (load/unload regions dynamically), floating origin (prevent precision jitter beyond 5000 units), HLOD (hierarchical LOD for distant meshes), persistent state (track entity changes across unloaded chunks), POI discovery systems (compass, markers), and threaded loading (prevent stutters). Use for RPGs, sandboxes, or exploration games. Trigger keywords: open_world, chunk_streaming, floating_origin, HLOD, persistent_state, POI_discovery, threaded_loading.",
    "keywords": [
      "open_world",
      "chunk_streaming",
      "floating_origin",
      "HLOD",
      "persistent_state",
      "POI_discovery",
      "threaded_loading"
    ]
  },
  {
    "name": "godot-genre-party",
    "description": "Expert blueprint for party games including minigame resource system (define via .tres files), local multiplayer input (4-player controller management), asymmetric gameplay (1v3 balance), scene management (clean minigame loading/unloading), persistent scoring (track wins across rounds), and split-screen rendering (SubViewport per player). Use for Mario Party-style games or WarioWare collections. Trigger keywords: party_game, minigame_collection, local_multiplayer, asymmetric_gameplay, split_screen, dynamic_input_mapping.",
    "keywords": [
      "party_game",
      "minigame_collection",
      "local_multiplayer",
      "asymmetric_gameplay",
      "split_screen",
      "dynamic_input_mapping"
    ]
  },
  {
    "name": "godot-genre-platformer",
    "description": "Expert blueprint for platformer games including precision movement (coyote time, jump buffering, variable jump height), game feel polish (squash/stretch, particle trails, camera shake), level design principles (difficulty curves, checkpoint placement), collectible systems (progression rewards), and accessibility options (assist mode, remappable controls). Based on Celeste/Hollow Knight design research. Trigger keywords: platformer, coyote_time, jump_buffer, game_feel, level_design, precision_movement.",
    "keywords": [
      "platformer",
      "coyote_time",
      "jump_buffer",
      "game_feel",
      "level_design",
      "precision_movement"
    ]
  },
  {
    "name": "godot-genre-puzzle",
    "description": "Expert blueprint for puzzle games including undo systems (Command pattern for state reversal), grid-based logic (Sokoban-style mechanics), non-verbal tutorials (teach through level design), win condition checking, state management, and visual feedback (instant confirmation of valid moves). Use for logic puzzles, physics puzzles, or match-3 games. Trigger keywords: puzzle_game, undo_system, command_pattern, grid_logic, non_verbal_tutorial, state_management.",
    "keywords": [
      "puzzle_game",
      "undo_system",
      "command_pattern",
      "grid_logic",
      "non_verbal_tutorial",
      "state_management"
    ]
  },
  {
    "name": "godot-genre-racing",
    "description": "Expert blueprint for racing games including vehicle physics (VehicleBody3D, suspension, friction), checkpoint systems (prevent shortcuts), rubber-banding AI (keep races competitive), drifting mechanics (reduce friction, boost on exit), camera feel (FOV increase with speed, motion blur), and UI (speedometer, lap timer, minimap). Use for arcade racers, kart racing, or realistic sims. Trigger keywords: racing_game, vehicle_physics, checkpoint_system, rubber_banding, drifting_mechanics, camera_feel.",
    "keywords": [
      "racing_game",
      "vehicle_physics",
      "checkpoint_system",
      "rubber_banding",
      "drifting_mechanics",
      "camera_feel"
    ]
  },
  {
    "name": "godot-genre-rhythm",
    "description": "Expert blueprint for rhythm games including audio synchronization (BPM conductor, latency compensation with AudioServer.get_time_since_last_mix), note highways (scroll speed, timing windows), judgment systems (Perfect/Great/Good/Bad/Miss), scoring with combo multipliers, input processing (lane-based, hold note detection), and chart/beatmap loading. Based on DDR/osu!/Beat Saber research. Trigger keywords: rhythm_game, audio_sync, timing_judgment, note_highway, combo_system, BPM_conductor, latency_compensation.",
    "keywords": [
      "rhythm_game",
      "audio_sync",
      "timing_judgment",
      "note_highway",
      "combo_system",
      "BPM_conductor",
      "latency_compensation"
    ]
  },
  {
    "name": "godot-genre-roguelike",
    "description": "Expert blueprint for roguelikes including procedural generation (Walker method, BSP rooms), permadeath with meta-progression (unlock persistence), run state vs meta state separation, seeded RNG (shareable runs), loot/relic systems (hook-based modifiers), and difficulty scaling (floor-based progression). Use for dungeon crawlers, action roguelikes, or roguelites. Trigger keywords: roguelike, procedural_generation, permadeath, meta_progression, seeded_RNG, relic_system, run_state.",
    "keywords": [
      "roguelike",
      "procedural_generation",
      "permadeath",
      "meta_progression",
      "seeded_RNG",
      "relic_system",
      "run_state"
    ]
  },
  {
    "name": "godot-genre-rts",
    "description": "Expert blueprint for real-time strategy games including unit selection (drag box, shift-add), command systems (move, attack, gather), pathfinding (NavigationAgent2D with RVO avoidance), fog of war (SubViewport mask shader), resource economy (gather/build loop), and AI opponents (behavior trees, utility AI). Use for base-building RTS or tactical combat games. Trigger keywords: RTS, unit_selection, command_system, fog_of_war, pathfinding_RVO, resource_economy, command_queue.",
    "keywords": [
      "RTS",
      "unit_selection",
      "command_system",
      "fog_of_war",
      "pathfinding_RVO",
      "resource_economy",
      "command_queue"
    ]
  },
  {
    "name": "godot-genre-sandbox",
    "description": "Expert blueprint for sandbox games (Minecraft, Terraria, Garry's Mod) with physics-based interactions, cellular automata, emergent gameplay, and creative tools. Use when building open-world creation games with voxels, element systems, player-created structures, or procedural worlds. Keywords voxel, sandbox, cellular automata, MultiMesh, chunk management, emergent behavior, creative mode.",
    "keywords": [
      "voxel",
      "sandbox",
      "cellular automata",
      "MultiMesh",
      "chunk management",
      "emergent behavior",
      "creative mode"
    ]
  },
  {
    "name": "godot-genre-shooter",
    "description": "Expert blueprint for FPS/TPS shooter games (Call of Duty, Counter-Strike, Apex Legends, Fortnite) covering weapon systems, recoil patterns, hitscan vs projectile, aim assist, multiplayer prediction, and gunplay feel. Use when building competitive shooters, battle royales, or tactical FPS games requiring responsive combat. Keywords hitscan, recoil pattern, aim assist, client prediction, weapon archetype, projectile physics, hit registration.",
    "keywords": [
      "hitscan",
      "recoil pattern",
      "aim assist",
      "client prediction",
      "weapon archetype",
      "projectile physics",
      "hit registration"
    ]
  },
  {
    "name": "godot-genre-simulation",
    "description": "Expert blueprint for simulation and tycoon games (SimCity, RollerCoaster Tycoon, Factorio, Two Point Hospital) covering economy management, time progression, interconnected systems, NPC simulation, and feedback loops. Use when building management sims, tycoon games, city builders, or resource optimization games. Keywords tycoon, economy system, resource management, time scale, feedback loop, progression unlock, simulation tick.",
    "keywords": [
      "tycoon",
      "economy system",
      "resource management",
      "time scale",
      "feedback loop",
      "progression unlock",
      "simulation tick"
    ]
  },
  {
    "name": "godot-genre-sports",
    "description": "Expert blueprint for sports games (FIFA, NBA 2K, Rocket League, Tony Hawk) covering physics-based ball interaction, team AI formations, contextual input, and broadcast camera systems. Use when building soccer, basketball, hockey, racing sports, or arcade sports games. Keywords ball physics, magnus effect, formation AI, team tactics, contextual controls, steering behaviors.",
    "keywords": [
      "ball physics",
      "magnus effect",
      "formation AI",
      "team tactics",
      "contextual controls",
      "steering behaviors"
    ]
  },
  {
    "name": "godot-genre-stealth",
    "description": "Expert blueprint for stealth games (Splinter Cell, Hitman, Dishonored, Thief) covering AI detection systems, vision cones, sound propagation, alert states, light/shadow mechanics, and systemic design. Use when building stealth-action, tactical infiltration, or immersive sim games requiring enemy awareness systems. Keywords vision cone, detection, alert state, sound propagation, light level, systemic AI, gradual detection.",
    "keywords": [
      "vision cone",
      "detection",
      "alert state",
      "sound propagation",
      "light level",
      "systemic AI",
      "gradual detection"
    ]
  },
  {
    "name": "godot-genre-survival",
    "description": "Expert blueprint for survival games (Minecraft, Don't Starve, The Forest, Rust) covering needs systems, resource gathering, crafting recipes, base building, and progression balancing. Use when building open-world survival, crafting-focused, or resource management games. Keywords survival, needs system, crafting, inventory, hunger, resource gathering, base building.",
    "keywords": [
      "survival",
      "needs system",
      "crafting",
      "inventory",
      "hunger",
      "resource gathering",
      "base building"
    ]
  },
  {
    "name": "godot-genre-tower-defense",
    "description": "Expert blueprint for tower defense games (Bloons TD, Kingdom Rush, Fieldrunners) covering wave management, tower targeting logic, path algorithms, economy balance, and mazing mechanics. Use when building TD, lane defense, or tower placement strategy games. Keywords tower defense, wave spawner, pathfinding, targeting priority, mazing, NavigationServer baking.",
    "keywords": [
      "tower defense",
      "wave spawner",
      "pathfinding",
      "targeting priority",
      "mazing",
      "NavigationServer baking"
    ]
  },
  {
    "name": "godot-genre-visual-novel",
    "description": "Expert blueprint for visual novels (Doki Doki Literature Club, Phoenix Wright, Steins;Gate) focusing on branching narratives, dialogue systems, choice consequences, rollback mechanics, and persistent flags. Use when building story-driven, choice-based, or dating sim games. Keywords visual novel, dialogue system, branching narrative, typewriter effect, rollback, bbcode, RichTextLabel.",
    "keywords": [
      "visual novel",
      "dialogue system",
      "branching narrative",
      "typewriter effect",
      "rollback",
      "bbcode",
      "RichTextLabel"
    ]
  },
  {
    "name": "godot-input-handling",
    "description": "Expert patterns for input handling covering InputMap actions, InputEvent processing, controller support, rebinding, deadzones, and input buffering. Use when setting up player controls, implementing input systems, or adding gamepad/accessibility features. Keywords InputMap, InputEvent, gamepad, controller, rebinding, deadzone, input buffer.",
    "keywords": [
      "InputMap",
      "InputEvent",
      "gamepad",
      "controller",
      "rebinding",
      "deadzone",
      "input buffer"
    ]
  },
  {
    "name": "godot-inventory-system",
    "description": "Expert blueprint for inventory systems (Diablo, Resident Evil, Minecraft) covering slot-based containers, stacking logic, weight limits, equipment systems, and drag-drop UI. Use when building RPG inventories, survival item management, or loot systems. Keywords inventory, slot, stack, equipment, crafting, item, Resource, drag-drop.",
    "keywords": [
      "inventory",
      "slot",
      "stack",
      "equipment",
      "crafting",
      "item",
      "Resource",
      "drag-drop"
    ]
  },
  {
    "name": "godot-master",
    "description": "Master Map of Content (MOC) for the GDSkills library. This skill acts as a central index and discovery hub for all 80+ Godot-focused agentic skills. Use this to identify relevant skills for architecture, 2D/3D systems, gameplay mechanics, and optimization. Trigger keywords: MOC, index, table of contents, library map, skill discovery, Godot skills list.",
    "keywords": [
      "MOC",
      "index",
      "table of contents",
      "library map",
      "skill discovery",
      "Godot skills list"
    ]
  },
  {
    "name": "godot-mcp-scene-builder",
    "description": "\"[MCP WRAPPER] Programmatically create/modify Godot scenes using Godot MCP tools. Orchestrates mcp_godot_create_scene, mcp_godot_add_node, mcp_godot_load_sprite into agentic workflows. Use when user requests scene generation/automation via MCP. Keywords MCP, scene automation, programmatic scene building, node hierarchy.\"",
    "keywords": [
      "MCP",
      "scene automation",
      "programmatic scene building",
      "node hierarchy"
    ]
  },
  {
    "name": "godot-mcp-setup",
    "description": "\"[PREREQUISITE] Install and configure Godot MCP server for programmatic scene manipulation via Model Context Protocol. Use when user explicitly requests MCP-based scene building or automation. NOT for manual Godot workflows. Keywords MCP, Model Context Protocol, scene automation, npx, claude_desktop_config.\"",
    "keywords": [
      "MCP",
      "Model Context Protocol",
      "scene automation",
      "npx",
      "claude_desktop_config"
    ]
  },
  {
    "name": "godot-multiplayer-networking",
    "description": "Expert blueprint for multiplayer networking (Among Us, Brawlhalla, Terraria) using Godot's high-level API covering RPCs, state synchronization, authoritative servers, client prediction, and lobby systems. Use when building online multiplayer, LAN co-op, or networked games. Keywords multiplayer, RPC, ENetMultiplayerPeer, MultiplayerSynchronizer, authority, client prediction, rollback.",
    "keywords": [
      "multiplayer",
      "RPC",
      "ENetMultiplayerPeer",
      "MultiplayerSynchronizer",
      "authority",
      "client prediction",
      "rollback"
    ]
  },
  {
    "name": "godot-navigation-pathfinding",
    "description": "Expert blueprint for AI pathfinding (tower defense, RTS, stealth) using NavigationAgent2D/3D, NavigationServer, avoidance, and dynamic navigation mesh generation. Use when implementing enemy AI, NPC movement, or obstacle avoidance. Keywords NavigationAgent2D, NavigationRegion2D, pathfinding, NavigationServer, avoidance, baking, NavigationObstacle.",
    "keywords": [
      "NavigationAgent2D",
      "NavigationRegion2D",
      "pathfinding",
      "NavigationServer",
      "avoidance",
      "baking",
      "NavigationObstacle"
    ]
  },
  {
    "name": "godot-particles",
    "description": "Expert blueprint for GPU particle systems (explosions, magic effects, weather, trails) using GPUParticles2D/3D, ParticleProcessMaterial, gradients, sub-emitters, and custom shaders. Use when creating VFX, environmental effects, or visual feedback. Keywords GPUParticles2D, ParticleProcessMaterial, emission_shape, color_ramp, sub_emitter, one_shot.",
    "keywords": [
      "GPUParticles2D",
      "ParticleProcessMaterial",
      "emission_shape",
      "color_ramp",
      "sub_emitter",
      "one_shot"
    ]
  },
  {
    "name": "godot-performance-optimization",
    "description": "Expert blueprint for performance profiling and optimization (frame drops, memory leaks, draw calls) using Godot Profiler, object pooling, visibility culling, and bottleneck identification. Use when diagnosing lag, optimizing for target FPS, or reducing memory usage. Keywords profiling, Godot Profiler, bottleneck, object pooling, VisibleOnScreenNotifier, draw calls, MultiMesh.",
    "keywords": [
      "profiling",
      "Godot Profiler",
      "bottleneck",
      "object pooling",
      "VisibleOnScreenNotifier",
      "draw calls",
      "MultiMesh"
    ]
  },
  {
    "name": "godot-physics-3d",
    "description": "Expert patterns for Godot 3D physics (Jolt/PhysX), including Ragdolls, PhysicalBones, Joint3D constraints, RayCasting optimizations, and collision layers. Use for rigid body simulations, character physics, or complex interactions. Trigger keywords: RigidBody3D, PhysicalBone3D, Jolt, Ragdoll, Skeleton3D, Joint3D, PinJoint3D, HingeJoint3D, Generic6DOFJoint3D, RayCast3D, PhysicsDirectSpaceState3D.",
    "keywords": [
      "RigidBody3D",
      "PhysicalBone3D",
      "Jolt",
      "Ragdoll",
      "Skeleton3D",
      "Joint3D",
      "PinJoint3D",
      "HingeJoint3D",
      "Generic6DOFJoint3D",
      "RayCast3D",
      "PhysicsDirectSpaceState3D"
    ]
  },
  {
    "name": "godot-platform-console",
    "description": "Expert blueprint for console platforms (PlayStation, Xbox, Nintendo Switch) covering controller-first UI, certification requirements (TRCs/TCRs), platform services (achievements, cloud saves), and performance compliance. Use when targeting console releases or implementing gamepad-only interfaces. Keywords console, PlayStation, Xbox, Switch, TRC, TCR, certification, controller, gamepad, achievements.",
    "keywords": [
      "console",
      "PlayStation",
      "Xbox",
      "Switch",
      "TRC",
      "TCR",
      "certification",
      "controller",
      "gamepad",
      "achievements"
    ]
  },
  {
    "name": "godot-platform-desktop",
    "description": "Expert blueprint for desktop platforms (Windows/Linux/macOS) covering keyboard/mouse controls, settings menus, window management (fullscreen, resolution), keybind remapping, and Steam integration. Use when targeting PC platforms or implementing desktop-specific features. Keywords desktop, Windows, Linux, macOS, settings, keybinds, ConfigFile, DisplayServer, Steam, fullscreen.",
    "keywords": [
      "desktop",
      "Windows",
      "Linux",
      "macOS",
      "settings",
      "keybinds",
      "ConfigFile",
      "DisplayServer",
      "Steam",
      "fullscreen"
    ]
  },
  {
    "name": "godot-platform-mobile",
    "description": "Expert blueprint for mobile platforms (Android/iOS) covering touch controls, virtual joysticks, responsive UI, safe areas (notches), battery optimization, and app store guidelines. Use when targeting mobile releases or implementing touch input. Keywords mobile, Android, iOS, touch, InputEventScreenTouch, virtual joystick, safe area, battery, app store, orientation.",
    "keywords": [
      "mobile",
      "Android",
      "iOS",
      "touch",
      "InputEventScreenTouch",
      "virtual joystick",
      "safe area",
      "battery",
      "app store",
      "orientation"
    ]
  },
  {
    "name": "godot-platform-vr",
    "description": "Expert blueprint for VR platforms (Meta Quest, PSVR, SteamVR, Pico) covering XR toolkit (OpenXR), comfort settings (vignetting, snap turning, teleport), motion controls, hand tracking, and 90+ FPS requirements. Use when targeting VR headsets or implementing immersive 3D experiences. Keywords VR, XR, OpenXR, Meta Quest, motion sickness, comfort, locomotion, XRController3D, foveated rendering.",
    "keywords": [
      "VR",
      "XR",
      "OpenXR",
      "Meta Quest",
      "motion sickness",
      "comfort",
      "locomotion",
      "XRController3D",
      "foveated rendering"
    ]
  },
  {
    "name": "godot-platform-web",
    "description": "Expert blueprint for web/browser platforms (HTML5 export) covering WebGL/WebGPU rendering, custom loading screens, JavaScriptBridge integration, LocalStorage saves, and size optimization. Use when exporting to web or implementing browser-specific features. Keywords web, HTML5, WebGL, WebGPU, JavaScriptBridge, localStorage, canvas, browser API.",
    "keywords": [
      "web",
      "HTML5",
      "WebGL",
      "WebGPU",
      "JavaScriptBridge",
      "localStorage",
      "canvas",
      "browser API"
    ]
  },
  {
    "name": "godot-procedural-generation",
    "description": "Expert blueprint for procedural content generation (dungeons, terrain, loot, levels) using FastNoiseLite, random walks, BSP trees, Wave Function Collapse, and seeded randomization. Use when creating roguelikes, sandbox games, or dynamic content. Keywords procedural, generation, FastNoiseLite, Perlin noise, BSP, drunkard walk, Wave Function Collapse, seeding.",
    "keywords": [
      "procedural",
      "generation",
      "FastNoiseLite",
      "Perlin noise",
      "BSP",
      "drunkard walk",
      "Wave Function Collapse",
      "seeding"
    ]
  },
  {
    "name": "godot-project-foundations",
    "description": "Expert blueprint for Godot 4 project organization (feature-based folders, naming conventions, version control). Enforces snake_case files, PascalCase nodes, %SceneUniqueNames, and .gitignore best practices. Use when starting new projects or refactoring structure. Keywords project organization, naming conventions, snake_case, PascalCase, feature-based, .gitignore, .gdignore.",
    "keywords": [
      "project organization",
      "naming conventions",
      "snake_case",
      "PascalCase",
      "feature-based"
    ]
  },
  {
    "name": "godot-project-templates",
    "description": "Expert blueprint for genre-specific project boilerplates (2D platformer, top-down RPG, 3D FPS) including directory structures, AutoLoad patterns, and core systems. Use when bootstrapping new projects or migrating architecture. Keywords project templates, boilerplate, 2D platformer, RPG, FPS, AutoLoad, scene structure.",
    "keywords": [
      "project templates",
      "boilerplate",
      "2D platformer",
      "RPG",
      "FPS",
      "AutoLoad",
      "scene structure"
    ]
  },
  {
    "name": "godot-quest-system",
    "description": "Expert blueprint for quest  tracking systems (objectives, progress, rewards, branching chains) using Resource-based quests, signal-driven updates, and AutoLoad managers. Use when implementing RPG quests or mission systems. Keywords quest, objectives, Quest Resource, QuestObjective, signal-driven, branching, rewards, AutoLoad.",
    "keywords": [
      "quest",
      "objectives",
      "Quest Resource",
      "QuestObjective",
      "signal-driven",
      "branching",
      "rewards",
      "AutoLoad"
    ]
  },
  {
    "name": "godot-resource-data-patterns",
    "description": "Expert blueprint for data-oriented design using Resource/RefCounted classes (item databases, character stats, reusable data structures). Covers typed arrays, serialization, nested resources, and resource caching. Use when implementing data systems OR inventory/stats/dialogue databases. Keywords Resource, RefCounted, ItemData, CharacterStats, database, serialization, @export, typed arrays.",
    "keywords": [
      "Resource",
      "RefCounted",
      "ItemData",
      "CharacterStats",
      "database",
      "serialization",
      "@export",
      "typed arrays"
    ]
  },
  {
    "name": "godot-rpg-stats",
    "description": "Expert blueprint for RPG stat systems (attributes, leveling, modifiers, damage formulas) using Resource-based stats, stackable modifiers, and derived stat calculations. Use when implementing character progression OR equipment/buff systems. Keywords stats, attributes, leveling, modifiers, CharacterStats, derived stats, damage calculation, XP.",
    "keywords": [
      "stats",
      "attributes",
      "leveling",
      "modifiers",
      "CharacterStats",
      "derived stats",
      "damage calculation",
      "XP"
    ]
  },
  {
    "name": "godot-save-load-systems",
    "description": "Expert blueprint for save/load systems using JSON/binary serialization, PERSIST group pattern, versioning, and migration. Covers player progress, settings, game state persistence, and error recovery. Use when implementing save systems OR data persistence. Keywords save, load, JSON, FileAccess, user://, serialization, version migration, PERSIST group.",
    "keywords": [
      "save",
      "load",
      "JSON",
      "FileAccess",
      "user://",
      "serialization",
      "version migration",
      "PERSIST group"
    ]
  },
  {
    "name": "godot-scene-management",
    "description": "Expert blueprint for scene loading, transitions, async (background) loading, instance management, and caching. Covers fade transitions, loading screens, dynamic spawning, and scene persistence. Use when implementing level changes OR dynamic content loading. Keywords scene, loading, transition, async, ResourceLoader, change_scene, preload, PackedScene, fade.",
    "keywords": [
      "scene",
      "loading",
      "transition",
      "async",
      "ResourceLoader",
      "change_scene",
      "preload",
      "PackedScene",
      "fade"
    ]
  },
  {
    "name": "godot-server-architecture",
    "description": "Expert blueprint for low-level server access (RenderingServer, PhysicsServer2D/3D, NavigationServer) using RIDs for maximum performance. Bypasses scene tree overhead for procedural generation, particle systems, and voxel engines. Use when nodes are too slow OR managing thousands of objects. Keywords RenderingServer, PhysicsServer, NavigationServer, RID, canvas_item, body_create, low-level, performance.",
    "keywords": [
      "RenderingServer",
      "PhysicsServer",
      "NavigationServer",
      "RID",
      "canvas_item",
      "body_create",
      "low-level",
      "performance"
    ]
  },
  {
    "name": "godot-shaders-basics",
    "description": "Expert blueprint for shader programming (visual effects, post-processing, material customization) using Godot's GLSL-like shader language. Covers canvas_item (2D), spatial (3D), uniforms, built-in variables, and performance. Use when implementing custom effects OR stylized rendering. Keywords shader, GLSL, fragment, vertex, canvas_item, spatial, uniform, UV, COLOR, ALBEDO, post-processing.",
    "keywords": [
      "shader",
      "GLSL",
      "fragment",
      "vertex",
      "canvas_item",
      "spatial",
      "uniform",
      "UV",
      "COLOR",
      "ALBEDO",
      "post-processing"
    ]
  },
  {
    "name": "godot-signal-architecture",
    "description": "Expert blueprint for signal-driven architecture using \"Signal Up, Call Down\" pattern for loose coupling. Covers typed signals, signal chains, one-shot connections, and AutoLoad event buses. Use when implementing event systems OR decoupling nodes. Keywords signal, emit, connect, CONNECT_ONE_SHOT, CONNECT_REFERENCE_COUNTED, event bus, AutoLoad, decoupling.",
    "keywords": [
      "signal",
      "emit",
      "connect",
      "CONNECT_ONE_SHOT",
      "CONNECT_REFERENCE_COUNTED",
      "event bus",
      "AutoLoad",
      "decoupling"
    ]
  },
  {
    "name": "godot-skill-discovery",
    "description": "Expert blueprint for GDSkills skill discovery and indexing system. Enables AI agents to find relevant skills by topic/keyword. Use when building skill libraries OR implementing search functionality. Keywords skill discovery, indexing, search, metadata, skill registry.",
    "keywords": [
      "skill discovery",
      "indexing",
      "search",
      "metadata",
      "skill registry"
    ]
  },
  {
    "name": "godot-skill-judge",
    "description": "Meta-skill for validating the integrity and quality of other skills. automatically checks for SKILL.md existence, script syntax errors (via Godot CLI), and metadata completeness. Use this skill to verify the entire skill library. Trigger keywords: validation, continuous_integration, quality_assurance, syntax_check, metadata_check.",
    "keywords": [
      "validation",
      "continuous_integration",
      "quality_assurance",
      "syntax_check",
      "metadata_check"
    ]
  },
  {
    "name": "godot-state-machine-advanced",
    "description": "Expert blueprint for hierarchical finite state machines (HSM) and pushdown automata for complex AI/character behaviors. Covers state stacks, sub-states, transition validation, and state context passing. Use when basic FSMs are insufficient OR implementing layered AI. Keywords state machine, HSM, hierarchical, pushdown automata, state stack, FSM, AI behavior.",
    "keywords": [
      "state machine",
      "HSM",
      "hierarchical",
      "pushdown automata",
      "state stack",
      "FSM",
      "AI behavior"
    ]
  },
  {
    "name": "godot-testing-patterns",
    "description": "Expert blueprint for testing patterns using GUT (Godot Unit Test), integration tests, mock/stub patterns, async testing, and validation techniques. Covers assert patterns, signal testing, and CI/CD integration. Use when implementing tests OR validating game logic. Keywords GUT, unit test, integration test, assert, mock, stub, GutTest, watch_signals, TDD.",
    "keywords": [
      "GUT",
      "unit test",
      "integration test",
      "assert",
      "mock",
      "stub",
      "GutTest",
      "watch_signals",
      "TDD"
    ]
  },
  {
    "name": "godot-tilemap-mastery",
    "description": "Expert blueprint for TileMapLayer and TileSet systems for efficient 2D level design. Covers terrain autotiling, physics layers, custom data, navigation integration, and runtime manipulation. Use when building grid-based levels OR implementing destructible tiles. Keywords TileMapLayer, TileSet, terrain, autotiling, atlas, physics layer, custom data.",
    "keywords": [
      "TileMapLayer",
      "TileSet",
      "terrain",
      "autotiling",
      "atlas",
      "physics layer",
      "custom data"
    ]
  },
  {
    "name": "godot-turn-system",
    "description": "Expert blueprint for turn-based combat with turn order, action points, phase management, and timeline systems for strategy/RPG games. Covers speed-based initiative, interrupts, and simultaneous turns. Use when implementing turn-based combat OR tactical systems. Keywords turn-based, initiative, action points, phase, round, turn order, combat.",
    "keywords": [
      "turn-based",
      "initiative",
      "action points",
      "phase",
      "round",
      "turn order",
      "combat"
    ]
  },
  {
    "name": "godot-tweening",
    "description": "Expert blueprint for programmatic animation using Tween for smooth property transitions, UI effects, camera movements, and juice. Covers easing functions, parallel tweens, chaining, and lifecycle management. Use when implementing UI animations OR procedural movement. Keywords Tween, easing, interpolation, EASE_IN_OUT, TRANS_CUBIC, tween_property, tween_callback.",
    "keywords": [
      "Tween",
      "easing",
      "interpolation",
      "EASE_IN_OUT",
      "TRANS_CUBIC",
      "tween_property",
      "tween_callback"
    ]
  },
  {
    "name": "godot-ui-containers",
    "description": "Expert blueprint for responsive UI layouts using Container nodes (HBoxContainer, VBoxContainer, GridContainer, MarginContainer, ScrollContainer). Covers size flags, anchors, split containers, and dynamic layouts. Use when building adaptive interfaces OR implementing responsive menus. Keywords Container, HBoxContainer, VBoxContainer, GridContainer, size_flags, EXPAND_FILL, anchors, responsive.",
    "keywords": [
      "Container",
      "HBoxContainer",
      "VBoxContainer",
      "GridContainer",
      "size_flags",
      "EXPAND_FILL",
      "anchors",
      "responsive"
    ]
  },
  {
    "name": "godot-ui-rich-text",
    "description": "Expert blueprint for RichTextLabel with BBCode formatting (bold, italic, colors, images, clickable links) and custom effects. Covers meta tags, RichTextEffect shaders, and dynamic content. Use when implementing dialogue systems OR formatted text. Keywords RichTextLabel, BBCode, [b], [color], [url], meta_clicked, RichTextEffect, dialogue.",
    "keywords": [
      "RichTextLabel",
      "BBCode",
      "[b]",
      "[color]",
      "[url]",
      "meta_clicked",
      "RichTextEffect",
      "dialogue"
    ]
  },
  {
    "name": "godot-ui-theming",
    "description": "Expert blueprint for UI themes using Theme resources, StyleBoxes, custom fonts, and theme overrides for consistent visual styling. Covers StyleBoxFlat/Texture, theme inheritance, dynamic theme switching, and font variations. Use when implementing consistent UI styling OR supporting multiple themes. Keywords Theme, StyleBox, StyleBoxFlat, add_theme_override, font, theme inheritance, dark mode.",
    "keywords": [
      "Theme",
      "StyleBox",
      "StyleBoxFlat",
      "add_theme_override",
      "font",
      "theme inheritance",
      "dark mode"
    ]
  }
]